python <<EOF
# -*- coding: utf-8 -*-

import os
import sys

locallib = "/usr/local/lib/python2.7/site-packages"
if os.path.exists(locallib) and locallib not in sys.path:
    sys.path.insert(0, locallib)

import vim
import markdown2

from bs4 import BeautifulSoup
from tempfile import mkstemp
from gdata.blogger.client import BloggerClient


############# PostBlogger class and instance ################

class PostBlogger(object):
    def __init__(self):
        homedir = os.getenv("HOME")
        self.rcfile = os.path.join(homedir, ".vimbloggerrc")
        self.dictfile = os.path.join(homedir, ".vimblogger_labels")
        self.dictfile_words = os.path.join(homedir, ".vimblogger_words")

        try:
            if not os.path.exists(self.rcfile):
                raise Exception(self.rcfile + " does not exist!")
            with open(self.rcfile) as rcfh:
                rcinfo = rcfh.read()
                self.gaccount, self.gpass, self.blogid = rcinfo.strip().split()[:3]

            if not os.path.exists(self.dictfile):
                self.labellist = []
                with open(self.dictfile, "w") as dictfh:
                    dictfh.write("")
            else:
                with open(self.dictfile) as dictfh:
                    self.labellist = dictfh.read().split()

            if not os.path.exists(self.dictfile_words):
                with open(self.dictfile_words, "w") as wordsfh:
                    wordsfh.write("")

        except Exception as e:
            sys.stderr.write(e.message + "\n")

        self.client = BloggerClient()
        self.client.client_login(email=self.gaccount, password=self.gpass, source='blogger.vim')
        self.posts_cache = {}

    def newpost(self):
        fd, temppath = mkstemp(suffix=".vimBlogger.html")
        temppath = os.path.realpath(temppath)
        # print("Created file " + temppath)
        # register new post in cache
        self.posts_cache[temppath] = {"fd": fd, "postobj": None}
        return temppath

    def __del__(self):
        # close files after things are finished!
        for key in self.posts_cache:
            os.close(self.posts_cache[key]["fd"])
            os.remove(key)
            print("Closed fd for file: " + key)
            print("Deleted file: " + key)



blogger = PostBlogger()
############# PostBlogger class and instance ################

############# Templates ####################
posttemplate = """
<!-- ##################################
        Title of your cool blog post
        (plain text)
     ################################## -->
<posttitle>
sample title
</posttitle>

<!-- ##################################
        Content of your cool blog post
        (html format)
     ################################## -->
<content>
# sample content
</content>

<!-- ########################################################################
        Labels, one per line, starts with @@, c-x c-k for autocompletion
     ######################################################################## -->
<labels>
@@java
@@c
</labels>
"""
############# Templates ####################

EOF

function! Bnew()
python <<EOF
# -*- coding: utf-8 -*-

temppath = blogger.newpost()
# open buffer, setup template
vim.command("e {}".format(temppath))
vim.command("setl ft=html")
cb = vim.current.buffer
cb[:] = posttemplate.split("\n")
EOF
endfunction


function! Bpost()
python << EOF
# -*- coding: utf-8 -*-

currentpath = vim.eval("expand('%:p')")
# post file must be registered in the cache!
if not currentpath in blogger.posts_cache:
    raise Exception("This file is not generated by Bnew(), abort.")


# read and parse current buffer
cb = vim.current.buffer[:]
cbstring = "\n".join(cb)
soup = BeautifulSoup(cbstring, "html5lib")
posttitle = soup.posttitle.decode_contents().strip()
postcontent = soup.content.decode_contents().strip()
postlabels = soup.labels.decode_contents().strip()
postcontent = markdown2.markdown(postcontent)


if len(posttitle) == 0 or len(postcontent) == 0 or len(postlabels) == 0:
    raise Exception("Make sure title, content and labels are non-empty!")

# processing labels
postlabels = postlabels.split("@@")
postlabels = [x.strip() for x in postlabels]
postlabels = filter(bool, postlabels)
extralabels = [x for x in postlabels if x not in blogger.labellist]

if len(extralabels) > 0:
    blogger.labellist += extralabels
    with open(blogger.dictfile, "a") as labelfh:
        extralabel_string = "\n" + "\n".join(extralabels)
        print("New labels detected and added: ")
        print(extralabel_string)
        labelfh.write(extralabel_string)

# if post object not registered with path, make a new post, otherwise update it
if blogger.posts_cache[currentpath]["postobj"] is None:
    pobj = blogger.client.add_post(blog_id=blogger.blogid,
        title=posttitle, body=postcontent, labels=postlabels)
    blogger.posts_cache[currentpath]["postobj"] = pobj
    print("Post published and stored in cache.")
    print("{} post(s) in cache.".format(len(blogger.posts_cache)))
else:
    pobj = blogger.posts_cache[currentpath]["postobj"]
    if vim.eval("&modified") == "1":
        print("Post modified, I am going to updated it.")
        pobj.title.text = posttitle
        pobj.content.text = postcontent
        for label in postlabels:
            pobj.add_label(label)
        blogger.client.update(pobj)
        print("Post updated.")
    else:
        print("Nothing changed, don't bother me.")
EOF
endfunction


function! Bchecklabelhint()
python <<EOF
# -*- coding: utf-8 -*-

# if line starts with "@@", use labels dictionary for autocompletion
# else use English words
cl = vim.current.line
if cl.startswith("@@"):
    vim.command("setl dictionary=~/.vimblogger_labels")
else:
    vim.command("setl dictionary=~/.vimblogger_words")
EOF
endfunction
autocmd! CursorMoved *.vimBlogger.html call Bchecklabelhint()


command! -nargs=0  Bnew  call Bnew()
command! -nargs=0  Bpost call Bpost()
" autocmd! BufWrite *.vimBlogger.html call Bpost()
